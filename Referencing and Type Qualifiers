// Referencing and Type Qualifiers

//A feature that allows you to create an alias(alternative name) for a variable  and any operation performed on the reference directly affects the original variable.

Where would you see referencing?

(1) Reference declaration

Example 
int a = 5;     
int &ref = a;  // ref is a reference to a, (note how a was initialized, now the reference cannot be changed to another name)//now if ref is change to 24  then a changes too.
a referencerence can be constant(cannot be modiefied) this is done by adding the "const" type modifier to the reference..."const int &ref = a;" but this is mostly done when passing large object  you don't want modified(done by const) and copied(done by &)

(2)Passing Arguments by Reference
//When you pass arguments to functions by reference, the function can modify the original variables (if they are non-const) not the copies typically made.
Example 1
void modify(int &x) {
    x = 20;
}
int num = 10;
modify(num);  // num becomes 20
Example 2
// Question 6: Friend Function
class Rectangle {
private:
    int width, height;

public:
    // Constructor
    Rectangle(int w, int h) : width(w), height(h) {}

    // Friend function to calculate the area
    friend int calculateArea(Rectangle &r);
};

// Friend function definition
int calculateArea(Rectangle &r) {
    return r.width * r.height; // Access private members directly
}// above is a class Rectangle at an instance r that has been passed to the function, though this is a smaller class we will assume it is very big, in which case by referencing here we have prevented the creation of a Rectangle class copy from being made and saved memory (ignore the specifics of the friend function and focus on what I am trying to push across to you)

(3) Reference to Arrays
You can create references to arrays, but you have to be careful with the syntax
int arr[3] = {1, 2, 3};
int (&ref_arr)[3] = arr;  // ref_arr is a reference to the array arr

(4) Reference to a Pointer

You can also have references to pointers. This means you can modify the pointer itself (i.e., which object it points to).
Example 
int *p = &a;
int *&ref_p = p;  // ref_p is a reference to pointer p
//////////////////////////////////////////////////////////////////////////////////
To conclude, When you pass a variable by value, a copy of the variable is made, and the function works with that copy rather than the original variable and the changes made to the parameter inside the function do not affect the original argument outside the function, this is inefficient if the variable is large (like a large object or array) because a copy is created.
When you pass a variable by reference, the function gets a reference (alias) to the original variable, not a copy. This means any changes made to the parameter inside the function will affect the original variable, this is more efficient for large objects or structures, as no copy is made, if you further add const to the reference then pass it it means the function can use it but can make no changes to it.





/*/ Type Qualifiers

(1) Const
//Makes a variable or reference immutable/unchangeble (cannot be changed)

   (a) Constant Variable
      const int num = 10;
      num = 20;  // Error: cannot modify a constant variable

    (b)Constant Reference
       const int &ref = x;  // ref is a constant reference to x
       ref = 10;  // Error: cannot modify the value of x through the reference
(2) Unsigned
/// Indicates a variable can only store non-negative numbers, expanding the range of positive values(can store numbers between 0 to 4,294,967,295) the type(integer type) can hold.
unsigned int x = 10;
unsigned int y = 20;

(3) Signed
//Specifies that a variable can hold both negative and positive values (default for int). \
signed int a = -5;  // a can be negative because it is signed

(4) Void
//Represents an absence of value or return type.
   (a)Void Function Return Type: When a function does not return a value.
    void printMessage() {}

    (b) involves pointer????

(5)





































*/

