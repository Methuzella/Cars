// Referencing and Type Qualifiers

//A feature that allows you to create an alias(alternative name) for a variable  and any operation performed on the reference directly affects the original variable.

Where would you see referencing?

(1) Reference declaration

Example 
int a = 5;     
int &ref = a;  // ref is a reference to a, (note how a was initialized, now the reference cannot be changed to another name)//now if ref is change to 24  then a changes too.
a referencerence can be constant(cannot be modiefied) this is done by adding the "const" type modifier to the reference..."const int &ref = a;" but this is mostly done when passing large object  you don't want modified(done by const) and copied(done by &)

(2)Passing Arguments by Reference
//When you pass arguments to functions by reference, the function can modify the original variables (if they are non-const) not the copies typically made.
Example 1
void modify(int &x) {
    x = 20;
}
int num = 10;
modify(num);  // num becomes 20
Example 2
// Question 6: Friend Function
class Rectangle {
private:
    int width, height;

public:
    // Constructor
    Rectangle(int w, int h) : width(w), height(h) {}

    // Friend function to calculate the area
    friend int calculateArea(Rectangle &r);
};

// Friend function definition
int calculateArea(Rectangle &r) {
    return r.width * r.height; // Access private members directly
}// above is a class Rectangle at an instance r that has been passed to the function, though this is a smaller class we will assume it is very big, in which case by referencing here we have prevented the creation of a Rectangle class copy from being made and saved memory (ignore the specifics of the friend function and focus on what I am trying to push across to you)

(3) Reference to Arrays
You can create references to arrays, but you have to be careful with the syntax
int arr[3] = {1, 2, 3};
int (&ref_arr)[3] = arr;  // ref_arr is a reference to the array arr

(4) Reference to a Pointer

You can also have references to pointers. This means you can modify the pointer itself (i.e., which object it points to).
Example 
int *p = &a;
int *&ref_p = p;  // ref_p is a reference to pointer p
//////////////////////////////////////////////////////////////////////////////////
To conclude, When you pass a variable by value, a copy of the variable is made, and the function works with that copy rather than the original variable and the changes made to the parameter inside the function do not affect the original argument outside the function, this is inefficient if the variable is large (like a large object or array) because a copy is created.
When you pass a variable by reference, the function gets a reference (alias) to the original variable, not a copy. This means any changes made to the parameter inside the function will affect the original variable, this is more efficient for large objects or structures, as no copy is made, if you further add const to the reference then pass it it means the function can use it but can make no changes to it.





/*/ Type Qualifiers

(1) Const
//Makes a variable or reference immutable/unchangeble (cannot be changed)

   (a) Constant Variable
      const int num = 10;
      num = 20;  // Error: cannot modify a constant variable

    (b)Constant Reference
       const int &ref = x;  // ref is a constant reference to x
       ref = 10;  // Error: cannot modify the value of x through the reference
(2) Unsigned
/// Indicates a variable can only store non-negative numbers, expanding the range of positive values(can store numbers between 0 to 4,294,967,295) the type(integer type) can hold.
unsigned int x = 10;
unsigned int y = 20;

(3) Signed
//Specifies that a variable can hold both negative and positive values (default for int). \
signed int a = -5;  // a can be negative because it is signed

(4) Void
//Represents an absence of value or return type.
   (a)Void Function Return Type: When a function does not return a value.
    void printMessage() {}

    (b) involves pointer????

(5) Static

    (a) Static Variables
        // When applied to a variable inside a function, static ensures that the variable retains its value between function calls, MEANING THE variable value does not change back to its initial form if it has some form of increment in the function, it just keeps increasing the more the function is called
         example
         void counter() {
          static int count = 0;  // Retains value between function calls
          count++;
          std::cout << count << std::endl;
        } ////just call counter a bunch of times and you'll understand what I MEAN.

    (b)Static Variables at Global Level
       //When applied to a global variable or function, static restricts its visibility to the file in which it is declared (i.e., it cannot be accessed outside of the file).
        static int x = 5;  // Only accessible within this file

(6)Extern

//Declares that a variable or function that is defined in another file. It tells the compiler that the definition exists elsewhere, usually in another source file.
Example 
// In file1.cpp
int num = 10;

// In file2.cpp
extern int num;  // Declares that num is defined elsewhere (in file1.cpp)

(7) Typedef

//t is used to create an alias for an existing type.
Example
typedef unsigned int uint;
uint x = 10;  // x is an unsigned int


(8) Mutable 

//used inside a class to allow a member variable to be modified even if the object is declared as const. 
Example
class MyClass {
public:
    mutable int x;
    MyClass() : x(0) {}
};

int main() {
    const MyClass obj;  // Constant object
    obj.x = 10;  // Allowed because x is mutable
    return 0;
}



//Pointers

//A variable that holds the memory address(LOCATION WHRE DATA IS STORED) of another variable.
Example 
int *ptr;  // Pointer to an integer//The asterisk tells the compiler that this variable will hold a memory address of the specified type.
The actual memory address is assigned to the pointer as shown below
int num = 5;
int *ptr = &num;  // ptr now holds the address of num
//To get the an actual stored at the address the pointer points to we must derefernce the pointer,
int num = 5;
int *ptr = &num;  // ptr points to num
std::cout << *ptr;  // Dereferencing ptr to access the value of num, Outputs 5
// There are different types of pointers

   (1) Null Pointer
       //A null pointer is a pointer that does not point to any valid memory address.
       int *ptr = nullptr;  // ptr is a null pointer
    (2)Void Pointer
         //A void pointer is a pointer that can point to any data type but you cannot directly dereference a void pointer
         void *ptr;  // A void pointer
         int num = 5;
         ptr = &num;  // ptr can point to any type of data

         // To dereference a void pointer, cast it to the correct type
         std::cout << *(static_cast<int*>(ptr));  // Outputs 5
 
/////Angled brackets are typically used in C++ to represent something that needs a parameterizable type. This is used with static_cast to determine what data type the argument should be converted to (e.g. static_cast<int>(x) will return the value of x as an int).


*/

